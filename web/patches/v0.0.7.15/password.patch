diff -ur a/xpra/client.py b/xpra/client.py
--- a/xpra/client.py	2009-11-10 22:13:06.000000000 +0700
+++ b/xpra/client.py	2009-11-10 21:59:09.000000000 +0700
@@ -274,18 +274,18 @@
 gobject.type_register(ClientWindow)
 
 class XpraClient(gobject.GObject):
-    def __init__(self, sock, compression_level, jpegquality):
+    def __init__(self, sock, compression_level, jpegquality, title_suffix, password_file):
         gobject.GObject.__init__(self)
         self._window_to_id = {}
         self._id_to_window = {}
+        self.title_suffix = title_suffix
+        self.password_file = password_file
         self.compression_level = compression_level
         self.jpegquality = jpegquality
 
         self._protocol = Protocol(sock, self.process_packet)
         ClientSource(self._protocol)
-        root_w, root_h = gtk.gdk.get_default_root_window().get_size()
-        capabilities_request["desktop_size"] = [root_w, root_h]
-        self.send(["hello", capabilities_request])
+        self.send_hello()
 
         self._keymap = gtk.gdk.keymap_get_default()
         self._keymap.connect("keys-changed", self._keys_changed)
@@ -329,6 +329,29 @@
     def send_mouse_position(self, packet):
         self._protocol.source.queue_mouse_position_packet(packet)
 
+    def send_hello(self, hash=None):
+        capabilities_request = dict(default_capabilities)
+        if hash:
+            capabilities_request["challenge_response"] = hash
+        if self.compression_level:
+            capabilities_request["deflate"] = self.compression_level
+        if self.jpegquality:
+            capabilities_request["jpeg"] = self.jpegquality
+        root_w, root_h = gtk.gdk.get_default_root_window().get_size()
+        capabilities_request["desktop_size"] = [root_w, root_h]
+        self.send(["hello", capabilities_request])
+
+    def _process_challenge(self, packet):
+        if not self.password_file:
+            log.error("password is required by the server")
+            gtk.main_quit()
+            return
+        passwordFile = open(self.password_file, "rU")
+        password = passwordFile.read()
+        (_, salt) = packet
+        hash = hmac.HMAC(password, salt)
+        self.send_hello(hash.hexdigest())
+
     def _handle_xsettings_changed(self, *args):
         blob = self._xsettings_watcher.get_settings_blob()
         if blob is not None:
@@ -426,6 +449,7 @@
         gtk_main_quit_really()
 
     _packet_handlers = {
+        "challenge": _process_challenge,
         "hello": _process_hello,
         "new-window": _process_new_window,
         "new-override-redirect": _process_new_override_redirect,
diff -ur a/xpra/scripts/main.py b/xpra/scripts/main.py
--- a/xpra/scripts/main.py	2009-11-10 22:12:42.000000000 +0700
+++ b/xpra/scripts/main.py	2009-11-10 21:56:15.000000000 +0700
@@ -56,6 +56,9 @@
                       dest="bind_tcp", default=None,
                       metavar="[HOST]:PORT",
                       help="Listen for connections over TCP (insecure)")
+    parser.add_option("--password-file", action="store",
+                      dest="password_file", default=None,
+                      help="The file containing the password required to connect (useful to secure TCP mode)")
     parser.add_option("--title-suffix", action="store",
                       dest="title_suffix", default=" (via xpra)",
                       help="Text which is appended to the window's title")

diff -ur a/xpra/scripts/server.py b/xpra/scripts/server.py
--- a/xpra/scripts/server.py	2009-11-08 19:17:54.000000000 +0700
+++ b/xpra/scripts/server.py	2009-11-10 19:03:08.000000000 +0700
@@ -288,7 +288,7 @@
 
     # This import is delayed because the module depends on gtk:
     import xpra.server
-    app = xpra.server.XpraServer(upgrading, sockets)
+    app = xpra.server.XpraServer(upgrading, sockets, opts.password_file)
     def cleanup_socket(self):
         print "removing socket"
         try:
diff -ur a/xpra/server.py b/xpra/server.py
--- a/xpra/server.py	2009-11-10 22:12:42.000000000 +0700
+++ b/xpra/server.py	2009-11-10 19:11:57.000000000 +0700
@@ -308,6 +312,9 @@
         self._has_focus = 0
         self._upgrading = False
 
+        self.password_file = password_file
+        self.salt = None
+
         ### All right, we're ready to accept customers:
         for sock in sockets:
             self.add_listen_socket(sock)
@@ -517,11 +527,39 @@
         (_, client_capabilities) = packet
         log.info("Handshake complete; enabling connection")
         capabilities = self._calculate_capabilities(client_capabilities)
-        if capabilities.get("__prerelease_version") != xpra.__version__:
+        remote_version = capabilities.get("__prerelease_version")
+        if remote_version != xpra.__version__:
             log.error("Sorry, this pre-release server only works with clients "
-                      + "of exactly the same version (v%s)", xpra.__version__)
+                      + "of exactly the same version (v%s), but this client is using v%s", xpra.__version__, remote_version)
             proto.close()
             return
+        if self.password_file:
+            log.debug("password auth required")
+            client_hash = capabilities.get("challenge_response")
+            if not client_hash or not self.salt:
+                self.salt = "%s" % uuid.uuid4()
+                capabilities["challenge"] = self.salt
+                log.info("Password required, sending challenge: %s" % str(capabilities))
+                packet = ("challenge", self.salt)
+                from xpra.bencode import bencode
+                import select
+                data = bencode(packet)
+                written = 0
+                while written < len(data):
+                    select.select([], [proto._sock], [])
+                    written += proto._sock.send(data[written:])
+                return
+            passwordFile = open(self.password_file, "rU")
+            password  = passwordFile.read()
+            hash = hmac.HMAC(password, self.salt)
+            if client_hash != hash.hexdigest():
+                log.error("Password supplied does not match! dropping the connection.")
+                proto.close()
+                return
+            else:
+                log.info("Password matches!")
+                del capabilities["challenge_response"]
+                self.salt = None            #prevent replay attacks
         # Okay, things are okay, so let's boot out any existing connection and
         # set this as our new one:
         if self._protocol is not None:

